/*++

Copyright (c) 1996 ADVANCED MICRO DEVICES, INC. All Rights Reserved.
This software is unpblished and contains the trade secrets and 
confidential proprietary information of AMD. Unless otherwise provided
in the Software Agreement associated herewith, it is licensed in confidence
"AS IS" and is not to be reproduced in whole or part by any means except
for backup. Use, duplication, or disclosure by the Government is subject
to the restrictions in paragraph (b) (3) (B) of the Rights in Technical
Data and Computer Software clause in DFAR 52.227-7013 (a) (Oct 1988).
Software owned by Advanced Micro Devices, Inc., 901 Thompson Place,
Sunnyvale, CA 94088.

Module Name:

	interrup.c

Abstract:

	This file contains the interrupt handling routines.

Environment:

	Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

	$Log:   V:/pvcs/archives/network/pcnet/homelan/wince/mini4/src/interrup.c_y  $
 * 
 *    Rev 1.0   Apr 07 1999 18:13:30   jagannak
 * Initial check-in
 * 
 *    Rev 1.9   Mar 31 1999 12:08:28   cabansag
 *  
 * 
 *    Rev 1.56   02 Oct 1997 12:34:46   steiger
 * Changed status field in rx'd packet OOB data
 * from NDIS_STATUS_PENDING to NDIS_STATUS_RESOURCES.
 * This prevents protocols from retaining ownership
 * of a packet after the call to NdisMIndicateReceivePacket.
 * 
 * 
 *    Rev 1.55   30 Sep 1997 15:28:22   steiger
 * Added code to preserve the RAP register contents. Was causing data corruption when I/O macros were preempted because of LanceISR.
 * 
 * 
 *    Rev 1.55   30 Sep 1997 15:17:20   steiger
 * 
 * 
 * 
 *    Rev 1.54   02 Sep 1997 13:58:42   steiger
 * Modified LanceHandleInterrupt () so that the OWN bit is set immediately if the received packet
 * has an error and will not be placed in the packet array for the subsequent call to NdisMIndicateReceivePacket.
 * Also changed LanceHandleInterrupt () so that it no longer writes the address of LanceRMDFlags to the MiniportReserved
 * field of the NDIS packet descriptor; instead it is done during LanceSetupRegistersAndInit () in LANCE.C.
 * 
 * 
 *    Rev 1.53   20 Aug 1997 14:23:48   steiger
 * Further refinements to multi-send and multi-receive.
 * 
 * 
 *    Rev 1.52   12 Aug 1997 17:50:58   steiger
 * Multi-RX implemented. Copy/Compare testing has been done.

--*/

#include <ndis.h>
#include <efilter.h>
#include "lancehrd.h"
#include "lancesft.h"

#ifdef	NDIS40_PLUS

STATIC
VOID
XmitComplete (
	IN PLANCE_ADAPTER Adapter
	);

STATIC
VOID
RcvComplete (
	PNDIS_PACKET			*PktArray,
	PNDIS_BUFFER			*BufArray,
	USHORT					PktIndex
	);

#endif	/* NDIS40_PLUS */


VOID
LanceEnableInterrupt(
	IN NDIS_HANDLE Adapter
	)

/*++

Routine Description:

	This routine enables interrupts on the adapter.

Arguments:

	Adapter - Pointer to the adapter structure.

Return Value:

	None.

--*/

{
	USHORT			SavedRAPValue;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceEnableInterrupt\n");
	#endif

	/* Save RAP value */
	NdisRawReadPortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, &SavedRAPValue);

	/* Enable device interrupts	*/
	LANCE_WRITE_CSR(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_IENA);
	
	/* Restore RAP value */
	NdisRawWritePortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, SavedRAPValue);

	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceEnableInterrupt\n");
	#endif

}

VOID
LanceDisableInterrupt(
	IN NDIS_HANDLE Adapter
	)

/*++

Routine Description:

	This routine disables interrupts on the adapter.

Arguments:

	Adapter - Pointer to the adapter structure.

Return Value:

	None.

--*/

{
	USHORT			SavedRAPValue;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceDisableInterrupt\n");
	#endif

	/* Save RAP value */
	NdisRawReadPortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, &SavedRAPValue);

	/* Disable device interrupts.	Only IENA is affected by writing 0	*/
	LANCE_WRITE_CSR(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress, LANCE_CSR0, 0);

	/* Restore RAP value */
	NdisRawWritePortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, SavedRAPValue);

	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceDisableInterrupt\n");
	#endif
}


VOID
LanceISR(
	OUT PBOOLEAN InterruptRecognized,
	OUT PBOOLEAN QueueDpc,
	IN PVOID Context
	)

/*++

Routine Description:

	Interrupt service routine. Determines whether or not the interrupt was
	generated by our hardware, and if so, clears the source of the interrupt
	and queues a DPC (Deferred Procedure Call).

Arguments:

	InterruptRecongnized	Pointer to variable that is set by this routine.
							It is set TRUE if interrupt is ours, else FALSE.

	QueueDpc			 	TRUE if a DPC is queued. Only valid if
							InterruptRecognized is TRUE.

	Context					Essentially, a pointer to the adapter data
							structure.

Return Value:

	None

--*/

{

	PLANCE_ADAPTER	Adapter = Context;
	USHORT			Csr0Value;
	USHORT			SavedRAPValue;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceISR\n");
	#endif

	LOG(IN_ISR)

	/* Set default return value	*/
	*InterruptRecognized = FALSE;
	*QueueDpc = FALSE;

	/* Check reset flag. If the flag is set, we don't	*/
	/* own this interrupt	*/
	if (Adapter->OpFlags & RESET_IN_PROGRESS)
	{
  		#if DBG
		if (LanceDbg)
			DbgPrint("LanceISR: ABORT: Reset in Progress.\n");
		#endif
		return;
	}

	/* Save RAP value */
   NdisRawReadPortUshort(Adapter->MappedIoBaseAddress + LANCE_RAP_PORT, &SavedRAPValue);

	/* Read CSR0 value	*/
	LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, &Csr0Value);

	/* Check if we own this interrupt	*/
//	if (Csr0Value & (LANCE_CSR0_INTR | LANCE_CSR0_STOP))
	if ((Csr0Value & LANCE_CSR0_INTR) &&
		(Csr0Value & LANCE_CSR0_IENA))
	{
  		#if DBG
		if (LanceDbg)
			DbgPrint("LanceISR: This is my interrupt. %x\n",Csr0Value);
		#endif

		/* Disable interrupt source. Writing zeroes to the interrupt status */
		/* bits in CSR0 has no effect on them. All the other bits except	*/
		/* IENA (interrupt enable, bit 6) are read only.					*/
		LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, 0);

		/* Replace default return value	*/
		*InterruptRecognized = TRUE;

/* According to the NDIS 4.0 spec, *QueueDpc is set TRUE whenever a DPC is	*/
/* required to complete interrupt processing. Should always be TRUE			*/
/* whenever *InterruptRecognized is TRUE. I am unable to determine why it	*/
/* was originally coded as having anything to do with the interrupt signal	*/
/* type. (As in the original line commented out below)						*/

//		*QueueDpc = (Adapter->InterruptMode == NdisInterruptLevelSensitive);
		*QueueDpc = TRUE;

		/* Set interrupt flag	*/
		Adapter->OpFlags |= IN_INTERRUPT_DPC;
	}
	else
	{
		#if DBG
		if (LanceDbg)
			DbgPrint("LanceISR routine: Not my interrupt.\n");
		#endif
	}

	LOG(OUT_ISR)

	/* Restore RAP value */
	NdisRawWritePortUshort(Adapter->MappedIoBaseAddress + LANCE_RAP_PORT, SavedRAPValue);
	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceISR\n");
	#endif
}


VOID
LanceHandleInterrupt(
	IN PVOID Context
	)

/*++

Routine Description:

	This routine is queued by the interrupt service routine
	when deferred processing needs to be done, i.e. packet transmit
	completion, packet reception, etc.

Arguments:

	Context - A pointer to the adapter data structure.

Return Value:

	None.

--*/

{
	USHORT *		CurrBufferSize;
	USHORT *		CurrByteCount;
	UCHAR *			CurrRMDReserved1;
	UCHAR *			CurrRMDFlags;
	USHORT		Csr0Value;
	USHORT		uShortData;
	USHORT		GoodMulticastPacket = 1;
	
	/* Receive status of the packet.	*/
	ULONG ReceiveStatus;

	PLANCE_ADAPTER Adapter = (PLANCE_ADAPTER)Context;

	/* Pointer to the receive descriptor being examined.	*/
	//jk PLANCE_RECEIVE_DESCRIPTOR CurrentDescriptor;

	/* Pointer to the receive descriptor being examined.	*/
	PLANCE_RECEIVE_DESCRIPTOR_HI CurrentDescriptorHi;

	/* Receive buffer address	*/
	//jk NDIS_PHYSICAL_ADDRESS CurrentBufferPhysical;

	/* The virtual address of the packet.	*/
	PVOID PacketVa;

#ifndef NDIS40_PLUS
	/* Look adead packet size for indication	*/
	UINT LookAheadSize;
	NDIS_BUFFER Buffer;
#endif

	/* The size of the packet.	*/
	UINT PacketSize;

	/* Index to descriptor to be processed.	*/
	USHORT CurrentDescriptorIndex;

	BOOLEAN IndicatingPacket = FALSE;
	BOOLEAN IndicateRxComplete = FALSE;


	UINT	Data = 0;
	USHORT Time = 0;
	/* Receive packet type.	*/
	USHORT ReceivePacketType;
  	//jk USHORT Csr116Data;
	//jk UCHAR	DummyUchar;
//	ULONGLONG	SystemTime;
	USHORT	i; //jk ,j;

#ifdef NDIS40_PLUS
	
	PNDIS_PACKET *			PktArray = Adapter->PktArray;
	PNDIS_BUFFER *			BufArray = Adapter->BufArray;
	USHORT					PktIndex = 0;
	PNDIS_PACKET_OOB_DATA	OobPktData;
//	UINT phyCnt,bufCnt,length;

#endif

	PUCHAR					CRCSrc;
//	BOOLEAN					IsCancelled;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceHandleInterrupt\n");
	#endif

	LOG(IN_DPC)

#ifdef NDIS50_PLUS
	/* If PM mode is on, simply return */
	if (Adapter->OpFlags & PM_MODE)
	{
	#ifdef DBG
		if (LancePMDbg)
		DbgPrint("LanceHandleInterrupt : PM MODE is On\n");
	#endif
		Adapter->OpFlags &= ~IN_INTERRUPT_DPC;
//		Adapter->OpFlags &= ~RESET_PROHIBITED;
		
		LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, 4);
		return;
	}

#endif
	
	/* Check reset flag. If the flag is set, we don't	*/
	/* own this interrupt	*/
	if (Adapter->OpFlags & RESET_IN_PROGRESS)
	{
		#if DBG
		if (LanceDbg)
			DbgPrint("LanceHandleInterrupt: ABORT: Reset in Progress.\n");
		#endif
		return;

	}
 
	/* Read CSR0 for interrupts	*/
	LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, &Csr0Value);

	/* Check for receive interrupts.	*/
	if (Csr0Value & (LANCE_CSR0_RINT | LANCE_CSR0_MISS))
	{
		/* Handle receive interrupt	*/

		/* IndicatingReceiving = LanceProcessReceiveInterrupts(Adapter);	*/
		/* We don't get here unless there was a receive. Loop through		*/
		/* the receive descriptors starting at the last known descriptor	*/
		/* owned by the hardware that begins a packet and examine each 		*/
		/* receive ring descriptor for errors.								*/

		#if DBG
		if (LanceRxDbg)
			DbgPrint("Enter LanceReceiveInterrupt Loop.\n");
		#endif

		LOG(RECEIVE)

		Adapter->HLAC.RcvStateValid = TRUE;
//		NdisGetCurrentSystemTime(&SystemTime);

		while (TRUE) /* One loop traversal per received packet */
		{
			/* Point to current receive descriptor	*/
			CurrentDescriptorIndex = Adapter->NextReceiveDescriptorIndex;

			/* Since the structure template differs based on SwStyle & 	*/
			/* certain structure members are read/mod/written			*/
			/* multiple times for each received packet, we will get		*/
			/* pointers to the relevant members and thus avoid having	*/
			/* to test Adapter->SwStyle more than once each time we		*/
			/* need to access the current descriptor.					*/
			CurrentDescriptorHi	= (PLANCE_RECEIVE_DESCRIPTOR_HI)Adapter->ReceiveDescriptorRing +
									CurrentDescriptorIndex;
			ReceiveStatus 		= (ULONG)CurrentDescriptorHi->LanceRMDFlags;
			CurrBufferSize		= &(CurrentDescriptorHi->BufferSize);
			CurrByteCount 		= &(CurrentDescriptorHi->ByteCount);
			CurrRMDReserved1	= &(CurrentDescriptorHi->LanceRMDReserved1);
			CurrRMDFlags		= &(CurrentDescriptorHi->LanceRMDFlags);

#ifdef DMI
			if (ReceiveStatus & LANCE_RECEIVE_BUFFER_ERROR)
				++Adapter->DmiSpecific[DMI_RXBUFF_ERR];
#endif //DMI

			if (ReceiveStatus & OWN)
			{
				#if DBG
				if(LanceRxDbg && (!IndicatingPacket))
					/* No descriptors belonging to us were found */ 
					DbgPrint("LanceReceiveInterrupt: No rx descriptors to process.\n");

				#endif
				/* Clear interrupt source */
				LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, (LANCE_CSR0_RINT | LANCE_CSR0_MISS));

				/* Check status after clearing int */
				if (ReceiveStatus & OWN)
					break;	/* The only way out of this 'while' loop */
			}

#ifdef NDIS40_PLUS
			if (PktIndex >= RX_INT_WATERMARK)
			{
				NdisMIndicateReceivePacket(Adapter->LanceMiniportHandle, PktArray, PktIndex);
				RcvComplete (PktArray, BufArray, PktIndex);
				PktIndex = 0;
				IndicatingPacket = FALSE;
				IndicateRxComplete = TRUE;
			}
#endif //NDIS40_PLUS

			/* If we've made it to here, there must be at least one	*/
			/* descriptor to process ...							*/

			/* Check that the packet was received correctly.	*/
			/* As we have the buffer which can receive maximum size packet,	*/
			/* ENP and STP should be set.	*/
			if ((ReceiveStatus & DERR) ||
			  !((ReceiveStatus & ENP) && (ReceiveStatus & STP)))
			{

				#if DBG
					if (LanceRxDbg)
						DbgPrint("LanceReceiveInterrupt: Skipping this descriptor. Rx status = %lx\n", ReceiveStatus);
				#endif
#ifdef NDIS40_PLUS
				*CurrRMDFlags = OWN;
#endif

				if (Adapter->isAutoConfigOn &&
					(Adapter->ActivePhyAddress == HOMERUN_PHY_ADDRESS))
					CRCSrc = (PUCHAR)(Adapter->ReceiveBufferPointer +
								(CurrentDescriptorIndex * RECEIVE_BUFFER_SIZE)) +
								ETH_LENGTH_OF_ADDRESS;

				goto SkipIndication;	/* *YUK* */

			}

			/* Check if packet size is valid	*/
			PacketSize = *CurrByteCount - 4;

			if (PacketSize > LANCE_INDICATE_MAXIMUM)
			{
				#if DBG
					if (LanceRxDbg)
					DbgPrint("LanceReceiveInterrupt: Packet too large, length %d\n", PacketSize);
				#endif

#ifdef NDIS40_PLUS
				*CurrRMDFlags = OWN;
#endif
				goto SkipIndication;	/* *YUK* */
			}
/*
	MJ modified to check Multi-Rx.
*/
#ifndef NDIS40_PLUS
			LookAheadSize = PacketSize;
#endif
			PacketVa = (PVOID)(Adapter->ReceiveBufferPointer +
							(CurrentDescriptorIndex * RECEIVE_BUFFER_SIZE));

#ifdef DMI
			Adapter->DmiSpecific[DMI_RX_BYTES] += (COUNTER64) PacketSize;
#endif DMI

			/* Broadcast / multicast?	*/

			if (ETH_IS_MULTICAST(PacketVa))
			{
#if DBG
				if (ETH_IS_BROADCAST(PacketVa))
					ReceivePacketType = LANCE_BROADCAST;
				else
					ReceivePacketType = LANCE_MULTICAST;
#else
				ReceivePacketType = (ETH_IS_BROADCAST(PacketVa)) ?
									LANCE_BROADCAST : LANCE_MULTICAST;
#endif
			}
			else
			{
				ReceivePacketType = LANCE_DIRECTED;
			}
/* HY add for Homerun multicast process */
			/*
			if ((ReceivePacketType == LANCE_MULTICAST) && 
				(Adapter->ActivePhyAddress == HOMERUN_PHY_ADDRESS))
			{

				// check multicast address with destination MAC address of received packet
				for (i = 0; i < Adapter->NumberOfAddresses; i++) {
					GoodMulticastPacket = 0;
					for (j = 0; j < 6; j++)
					{
						if (Adapter->MulticastAddresses[i][j] != ((PUCHAR) PacketVa)[j])
							break;
					}
				
					if (j == 6)
					{
						GoodMulticastPacket = 1;
						break;
					}
				}
			
				if (!GoodMulticastPacket)
				{
					// not suppose to receive this multicast packet
//					goto SkipIndication;
					//	Restore the bcnt field, it is overwritten by HILANCE !
					*CurrBufferSize = -RECEIVE_BUFFER_SIZE;

					// Reset the Runt/.. Counts.
					*CurrRMDReserved1 = 0;

		
					*CurrRMDFlags = OWN;
		
					Adapter->LinkActive = TRUE;

					// Advance our pointers to the next descriptor.
					if ((++Adapter->NextReceiveDescriptorIndex) >= RECEIVE_BUFFERS)
					{
						Adapter->NextReceiveDescriptorIndex = 0;
					}
					continue;
				}
			}
*/


/*
	MJ modified to check Multi-Rx.
*/
#ifdef NDIS40_PLUS

		/* [Insert multi-rx code here.] */

		/* 1. Call NdisAdjustBufferLength () to match the size of the buffer with */
		/*    the size of the packet. */
			
			NdisAdjustBufferLength (Adapter->pNdisBuffer[CurrentDescriptorIndex], PacketSize);

		/* 2. Call NDIS_OOB_DATA_FROM_PACKET to get ptr to the OOB data */
			OobPktData = NDIS_OOB_DATA_FROM_PACKET(Adapter->pNdisPacket[CurrentDescriptorIndex]); 

		/* 3. Set OOB status to NDIS_STATUS_RESOURCES to retain ownership of the */
		/*    descriptor */
			OobPktData->Status = NDIS_STATUS_RESOURCES;
//			OobPktData->Status = NDIS_STATUS_SUCCESS;

//			NDIS_SET_PACKET_TIME_RECEIVED(Adapter->pNdisPacket[CurrentDescriptorIndex],SystemTime);

		/* 4. Call NdisFlushBuffer and NdisMUpdateSharedMemory to ensure data */
		/*    integrity. UPDATE: Both calls map to NULL in NDIS.H */
			NdisFlushBuffer (Adapter->pNdisBuffer[CurrentDescriptorIndex], FALSE);
			NdisMUpdateSharedMemory (Adapter->LanceMiniportHandle,
									PacketSize,
									PacketVa,
									Adapter->ReceiveBufferPointerPhysical +
									(CurrentDescriptorIndex	* RECEIVE_BUFFER_SIZE)
									);

		/* 5. Place packet pointer into the packet array & increment the packet array index. */
			BufArray[PktIndex] = Adapter->pNdisBuffer[CurrentDescriptorIndex];
			PktArray[PktIndex++] = Adapter->pNdisPacket[CurrentDescriptorIndex];
			IndicatingPacket = TRUE;

		/* 7. Repeat 1 thru 6 for all received packets. */

#else	/* *NOT* NDIS40_PLUS */

#if 1
			Buffer.Next = NULL;
			Buffer.MdlFlags = 0;
			Buffer.MappedSystemVa = PacketVa;
			Buffer.StartVa = PacketVa;
			Buffer.ByteCount = PacketSize;
			Buffer.ByteOffset = 0;
#else
			// jk following 3 lines - NDIS_BUFFER struct conforms to the Ndis.h 
			// file as defined in Windows CE 
			Buffer.Next=NULL;
			Buffer.VirtualAddress = PacketVa;
			Buffer.BufferLength= PacketSize;
#endif

			NdisFlushBuffer (&Buffer, FALSE);

			NdisMUpdateSharedMemory (Adapter->LanceMiniportHandle,
									PacketSize,
									PacketVa,
									Adapter->ReceiveBufferPointerPhysical +
									(CurrentDescriptorIndex	* RECEIVE_BUFFER_SIZE)
									);

			/* Indicate a packet is received and available	*/

			if (PacketSize < MAC_HEADER_SIZE)
			{

				/* Must have at least the destination address	*/

				if (PacketSize >= ETH_LENGTH_OF_ADDRESS)
				{
					/* Runt packet	*/
					NdisMEthIndicateReceive(
						Adapter->LanceMiniportHandle,
						(NDIS_HANDLE)((PUCHAR)PacketVa + MAC_HEADER_SIZE),	// context
						PacketVa,				// header buffer
						PacketSize,			// header buffer size
						NULL,					// lookahead buffer
						0,						// lookahead buffer size
						0						// Packet size not include header
						);
					IndicatingPacket = TRUE;
				}
			}
			else
			{
				NdisMEthIndicateReceive(
					Adapter->LanceMiniportHandle,
					(NDIS_HANDLE)((PUCHAR)PacketVa + MAC_HEADER_SIZE),	// context
					PacketVa,				// header buffer
					MAC_HEADER_SIZE,						// header buffer size
					(PUCHAR)PacketVa + MAC_HEADER_SIZE,	// lookahead buffer
					LookAheadSize - MAC_HEADER_SIZE,		// lookahead buffer size
					PacketSize - MAC_HEADER_SIZE			// packet size
					);

				IndicatingPacket = TRUE;
			}
#endif	/* NDIS40_PLUS */

SkipIndication:

			#if DBG
				if(LanceDbg && IndicatingPacket)
					DbgPrint("LanceReceiveInterrupt: One rx'd packet reported to system.\n");
//				else if(LanceRxDbg)
//					DbgBreakPoint();				
			#endif

			/*	Restore the bcnt field, it is overwritten by HILANCE!	*/
			*CurrBufferSize = -RECEIVE_BUFFER_SIZE;

			/* Reset the Runt/.. Counts.	*/
			*CurrRMDReserved1 = 0;
/*
	MJ modified to check Multi-Rx
*/
#ifndef NDIS40_PLUS
			*CurrRMDFlags = OWN;
#endif

			Adapter->LinkActive = TRUE;

			/* Advance our pointers to the next descriptor.	*/
			if ((++Adapter->NextReceiveDescriptorIndex) >= RECEIVE_BUFFERS)
			{
				Adapter->NextReceiveDescriptorIndex = 0;
			}

			/* Update statistics now based on the receive status.	*/
			if (ReceiveStatus & DERR)
			{

				++Adapter->GeneralMandatory[GM_RECEIVE_BAD];

				if (ReceiveStatus & LANCE_RECEIVE_CRC_ERROR)
				{
					++Adapter->GeneralOptional[GO_RECEIVE_CRC-GO_ARRAY_START];

//HomeLan : check CRC errors for AUTO Configuration.
					if (Adapter->isAutoConfigOn &&
						(Adapter->ActivePhyAddress == HOMERUN_PHY_ADDRESS))
					{
						LANCE_READ_MII(Adapter->MappedIoBaseAddress,
								(Adapter->ActivePhyAddress | HR_PHY_STATUS_REG), &uShortData);
						uShortData = (uShortData>>RECEIVED_SPEED_BIT) & 0x0003;
						switch (uShortData) {						
							case 1 : //LPHS
									uShortData = STATE_LPHS;
									break;
							case 2 : //HPLS									
									uShortData = STATE_HPLS;
									break;
							case 3 : //HPHS
									uShortData = STATE_HPHS;
									break;
							default :
									#ifdef DBG
									if (LanceHLDbg)
										DbgPrint("State of CRC packet is not acceptable\n");
									#endif
									uShortData = STATE_LPHS;
									break;
						}

						i = (USHORT)Adapter->HLAC.numberOfCRCs % MAX_NEIGHBOR_STORAGE;
						Adapter->HLAC.CRCStates |= uShortData << (i*STATE_BITS);
						NdisMoveMemory(&Adapter->HLAC.CRCSources[i][0],
											CRCSrc,
											ETH_LENGTH_OF_ADDRESS);
						++Adapter->HLAC.numberOfCRCs;
					}
				}
				else if (ReceiveStatus & LANCE_RECEIVE_FRAME_ERROR)
				{
					++Adapter->MediaMandatory[MM_RECEIVE_ERROR_ALIGNMENT];
				}
				else if (ReceiveStatus & LANCE_RECEIVE_BUFFER_ERROR)
				{
					++Adapter->MediaOptional[MO_RECEIVE_OVERRUN];
				}
			}
			else
			{
				++Adapter->GeneralMandatory[GM_RECEIVE_GOOD];

				if (ReceivePacketType == LANCE_BROADCAST)
				{
					++Adapter->GeneralOptionalFrameCount[GO_BROADCAST_RECEIVES];

					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_BROADCAST_RECEIVES],
								PacketSize);

				}
				else if (ReceivePacketType == LANCE_MULTICAST)
				{
					++Adapter->GeneralOptionalFrameCount[GO_MULTICAST_RECEIVES];
					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_MULTICAST_RECEIVES],
								PacketSize);

				}
				else
				{

					++Adapter->GeneralOptionalFrameCount[GO_DIRECTED_RECEIVES];
					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_DIRECTED_RECEIVES],
								PacketSize);
				}
			} /* END if (ReceiveStatus & DERR) */
		} /* END while (TRUE) */
/*
	MJ modified to check Multi_Rx
*/
#ifdef NDIS40_PLUS
		if (IndicatingPacket)
		{
			/* 8. Call NdisMIndicateReceivePacket() with a pointer to the packet array */
			NdisMIndicateReceivePacket(Adapter->LanceMiniportHandle, PktArray, PktIndex);
			RcvComplete (PktArray, BufArray, PktIndex);
			IndicateRxComplete = TRUE;
			IndicatingPacket = FALSE;
		}

		if (IndicateRxComplete)
		{
			if (Adapter->CableDisconnected == TRUE)
			{
				Adapter->CableDisconnected = FALSE;
				NdisMIndicateStatus (Adapter->LanceMiniportHandle,
									NDIS_STATUS_MEDIA_CONNECT,
									NULL,
									0
									);
				#if DBG
					if (LanceDbg)
					DbgPrint("Cable Connect reported.\n");
				#endif
			}

//			NdisMEthIndicateReceiveComplete(Adapter->LanceMiniportHandle);
		}

#else	/* *NOT* NDIS40_PLUS */

		/* For receiving packet, tell upper layer the job done	*/
		if (IndicatingPacket)
		{
			NdisMEthIndicateReceiveComplete(Adapter->LanceMiniportHandle);
		}
#endif	/* NDIS40_PLUS */
	}	/* END if (...) [Check for receive interrupts.]	*/

/****************************************************************************
* Process any transmit interrupts.											*
*****************************************************************************/

	if (Csr0Value & LANCE_CSR0_TINT)
	{
#ifdef NDIS40_PLUS

		/* Update stats for all completed transmit descriptors. */
		XmitComplete (Adapter);

#else /* *NOT* NDIS40_PLUS */

/* According to the NDIS 4.0 spec, this call is not used or necessary */
/* when the send routine returns NDIS_STATUS_SUCCESS, which it does in all cases */
/* "Conditionalized" the following line 07-30-97 M. Steiger */

	/* Clear interrupt source */
	LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_TINT);

	NdisMSendResourcesAvailable(Adapter->LanceMiniportHandle);

#endif /* NDIS40_PLUS */

		/* Clear no-reset flag	*/
//		Adapter->OpFlags &= ~RESET_PROHIBITED;
	}

	/* Check for errors	*/
	if (Csr0Value & LANCE_CSR0_ERR)
	{

#ifdef DMI
		++Adapter->DmiSpecific[DMI_CSR0_ERR];
#endif //DMI

		/* Clear interrupt source */
		LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0,
			(LANCE_CSR0_MERR | LANCE_CSR0_BABL | LANCE_CSR0_CERR | LANCE_CSR0_MISS));
		#if DBG
		if (LanceDbg)
		{
			DbgPrint("LanceHandleInterrupt: Error. CSR0 value: %x\n", Csr0Value);
		}
		#endif

		/* Check for different errors and take appropriate steps	*/
		/* to recover from it and update the statastics	*/
		if (Csr0Value & LANCE_CSR0_BABL)
		{
#ifdef DMI
			++Adapter->DmiSpecific[DMI_CSR0_BABL];
#endif //DMI
			/* Fatal error!	Transmit time-out	*/
			LOG(BABL)
		} 

		if (Csr0Value & LANCE_CSR0_MERR)
		{
#ifdef DMI
			++Adapter->DmiSpecific[DMI_CSR0_MERR];
#endif //DMI
			/* Fatal error! No DACK assert for bus master DMA	*/
			LOG(ERR)
		}

		/* Collision error	*/
		if (Csr0Value & LANCE_CSR0_CERR)
		{
			++Adapter->MediaOptional[MO_TRANSMIT_HEARTBEAT_FAILURE];
			LOG(HEART)
		}

		/* Receive descriptor is not available for coming frame	*/
		if (Csr0Value & LANCE_CSR0_MISS)
		{
			++Adapter->GeneralMandatory[GM_RECEIVE_NO_BUFFER];
			LOG(MISSED)
		}
	}


// for HomeLan
	if (Adapter->ActivePhyAddress == HOMERUN_PHY_ADDRESS)
	{
//		LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, &Csr0Value);
		
		if ((Csr0Value & LANCE_CSR0_RUNNING) != LANCE_CSR0_RUNNING)
		{
			#if DBG
			if (LanceDbg)
			{
				DbgPrint("LanceHandleInterrupt: Chip stopped. CSR0 = %x\n", Csr0Value);
			}
			#endif
	
			/* Restart chip	*/
//			NdisRawReadPortUshort(Adapter->MappedIoBaseAddress + LANCE_RESET_PORT, &Csr0Value);
	#if DBG
	if (LanceInitDbg)
		DbgPrint("LanceHandleInterrupt calls LanceInit.Chip problem\n");
	#endif
			LanceInit(Adapter,FALSE);
// testing purpose only
//++Adapter->MediaOptional[MO_RECEIVE_OVERRUN];
		}
	}

	/* Clean interrupt flag	*/
	Adapter->OpFlags &= ~IN_INTERRUPT_DPC;

	LOG(OUT_DPC)

	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceHandleInterrupt\n");
	#endif
}

#ifdef	NDIS40_PLUS
STATIC
VOID
XmitComplete (
	IN PLANCE_ADAPTER Adapter
	)
{
#ifdef NDIS40_MINIPORT
	if (Adapter->ActivePhyAddress != HOMERUN_PHY_ADDRESS)
	{
		Adapter->OpFlags &= ~TX_RESOURCES;
		NdisMSendResourcesAvailable(Adapter->LanceMiniportHandle);
	}
	else
#endif
	if(!(Adapter->OpFlags & LANCE_DEFERRED_SEND_PROCESSING))
		LanceDeferredSend(Adapter);

	/* Clear interrupt source */
	LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_TINT);

#if DBG
	if (LanceDbg)
		DbgPrint("<==XmitComplete\n");
#endif
}	/* End of function XmitComplete () */


STATIC
VOID
RcvComplete (
	PNDIS_PACKET			*PktArray,
	PNDIS_BUFFER			*BufArray,
	USHORT					PktIndex
	)
{
	USHORT					TempIndex;
	PNDIS_PACKET_OOB_DATA			OobyDoobyData;
			
	/* Adjust buffer lengths and dis-own each descriptor in FIFO order	*/
	/* whilst unwinding the index 	*/
	TempIndex = 0;	/* Start the index at 0 so the oldest is freed first */
	while (PktIndex--) /* Count the packet index down to 0 */
	{
		/* 9. Check each packet's status using NDIS_GET_PACKET_STATUS and ensure		*/
		/*    that status is equal to NDIS_STATUS_SUCCESS */
		if (NDIS_GET_PACKET_STATUS(PktArray[TempIndex]) != NDIS_STATUS_PENDING)
		{
			OobyDoobyData = NDIS_OOB_DATA_FROM_PACKET (PktArray[TempIndex]);
			NdisZeroMemory (OobyDoobyData, sizeof(PNDIS_PACKET_OOB_DATA));
			OobyDoobyData->HeaderSize = 14;
			OobyDoobyData->SizeMediaSpecificInfo = 0;
			OobyDoobyData->MediaSpecificInformation = NULL;
		
			/* 10. Restore each used buffer's size by calling NdisAdjustBufferLength () */
			NdisAdjustBufferLength(BufArray[TempIndex], RECEIVE_BUFFER_SIZE);
		}
		else	/* This should never happen. */
		{
			#if DBG
			if(LanceRxDbg)
			{
				DbgPrint("Packet number %i has been pended\n",TempIndex);
			}
			#endif
		}
		/* Using the address of CurrRMDFlags saved in the MiniportReserved field,	*/
		/* Set the ownership bit so that the descriptor belongs to LANCE			*/
		**((UCHAR **)&(PktArray[TempIndex]->MiniportReserved[0])) = OWN;
		TempIndex++; /* Increment the index */

	}
}

VOID
LanceReturnPacket(
	IN	NDIS_HANDLE	MiniportAdapterContext,
	IN PNDIS_PACKET Packet
	)
{
	UINT phyCnt,bufCnt,length;
	PNDIS_BUFFER pBuffer=NULL;
	PNDIS_PACKET_OOB_DATA OobyDoobyData;
	PLANCE_ADAPTER Adapter = (PLANCE_ADAPTER)MiniportAdapterContext;

	#if DBG
	if(LanceRxDbg)
	{
		DbgPrint("==> LanceReturnPacket\n");
	}
	#endif

	if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_SUCCESS)
	{
		OobyDoobyData = NDIS_OOB_DATA_FROM_PACKET (Packet);
		NdisZeroMemory (OobyDoobyData, sizeof(PNDIS_PACKET_OOB_DATA));
		OobyDoobyData->HeaderSize = 14;
		OobyDoobyData->SizeMediaSpecificInfo = 0;
		OobyDoobyData->MediaSpecificInformation = NULL;
		
		/* 10. Restore each used buffer's size by calling NdisAdjustBufferLength () */
		NdisQueryPacket(Packet,&phyCnt,&bufCnt,&pBuffer,&length);
		NdisAdjustBufferLength(pBuffer, RECEIVE_BUFFER_SIZE);
	}
	else
	{
		#if DBG
			if(LanceRxDbg)
			{
				DbgPrint("Packet Status is not SUCCESS, which should never happen\n");
				DbgBreakPoint();
			}
		#endif

	}
	/* Using the address of CurrRMDFlags saved in the MiniportReserved field,	*/
	/* Set the ownership bit so that the descriptor belongs to LANCE			*/
	**((UCHAR **)&(Packet->MiniportReserved[0])) = OWN;

	#if DBG
	if(LanceRxDbg)
	{
		DbgPrint("<== LanceReturnPacket\n");
	}
	#endif
}

#endif	/* NDIS40_PLUS */
